import { EventEmitter } from 'events';
import { DecisionRequest, DecisionResult, DecisionPolicy, ConflictResolution, DecisionAudit, DecisionMetrics } from '@/types/decision';
import { AgentRegistry } from './agent-registry';
import { ResourceManager } from './resource-manager';
export declare class DecisionEngine extends EventEmitter {
    private agentRegistry;
    private resourceManager;
    private policies;
    private escalationPolicies;
    private authorityMatrix;
    private auditLog;
    private pendingDecisions;
    private conflictResolutions;
    private decisionMetrics;
    constructor(agentRegistry: AgentRegistry, resourceManager: ResourceManager);
    initialize(): Promise<void>;
    makeDecision(request: DecisionRequest): Promise<DecisionResult>;
    private executeDecisionStrategy;
    private multiCriteriaStrategy;
    resolveConflict(type: string, conflictingItems: any[], strategy?: string): Promise<ConflictResolution>;
    createPolicy(policy: DecisionPolicy): Promise<string>;
    updatePolicy(policyId: string, updates: Partial<DecisionPolicy>): Promise<void>;
    deletePolicy(policyId: string): Promise<void>;
    private escalateDecision;
    checkAuthority(agentType: string, domain: string, level: string, context?: Record<string, any>): Promise<boolean>;
    private extractCriterionValue;
    private normalizeCriterionScore;
    private calculateConfidence;
    private findApplicablePolicies;
    private applyConstraints;
    private evaluateConstraint;
    private auditDecision;
    private initializeMetrics;
    private updateMetrics;
    private roundRobinStrategy;
    private leastLoadedStrategy;
    private createSimpleResult;
    private loadPolicies;
    private loadEscalationPolicies;
    private loadAuthorityMatrix;
    private setupDefaultPolicies;
    private validatePolicy;
    private evaluatePolicyConditions;
    private shouldEscalate;
    private findEscalationPolicy;
    private executeEscalation;
    private notifyHumanOperator;
    private hasRequiredLevel;
    private evaluateAuthorityConstraints;
    private evaluateDelegationConditions;
    private categoricalToNumeric;
    private resolveByTimestamp;
    private resolveByPriority;
    private resolveByNegotiation;
    private resolveByResourceSharing;
    private resolveByEscalation;
    private weightedRoundRobinStrategy;
    private capabilityBasedStrategy;
    private performanceBasedStrategy;
    private costOptimizedStrategy;
    private customStrategy;
    getMetrics(): DecisionMetrics;
    getPolicies(): Map<string, DecisionPolicy>;
    getAuditLog(requestId: string): DecisionAudit[];
}
//# sourceMappingURL=decision-engine.d.ts.map