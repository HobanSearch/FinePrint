// Configuration Service Tests\n// Comprehensive tests for configuration management functionality\n\nimport { ConfigurationService } from '../../services/configuration';\nimport { PrismaClient } from '@prisma/client';\nimport Redis from 'ioredis';\nimport { ERROR_CODES, createConfigurationError } from '../../utils/errors';\n\ndescribe('ConfigurationService', () => {\n  let configService: ConfigurationService;\n  let mockPrisma: jest.Mocked<PrismaClient>;\n  let mockRedis: jest.Mocked<Redis>;\n\n  beforeEach(() => {\n    mockPrisma = global.testUtils.createMockPrismaClient();\n    mockRedis = global.testUtils.createMockRedisClient();\n    configService = new ConfigurationService(mockPrisma, mockRedis);\n  });\n\n  describe('getConfiguration', () => {\n    it('should return configuration from cache if available', async () => {\n      const testConfig = global.testUtils.generateTestConfiguration();\n      mockRedis.get.mockResolvedValue(JSON.stringify(testConfig));\n\n      const result = await configService.getConfiguration(\n        'test-service',\n        'development'\n      );\n\n      expect(result).toEqual(testConfig);\n      expect(mockRedis.get).toHaveBeenCalledWith('config:test-service:development');\n      expect(mockPrisma.configuration.findFirst).not.toHaveBeenCalled();\n    });\n\n    it('should fetch from database if not in cache', async () => {\n      const testConfig = global.testUtils.generateTestConfiguration();\n      mockRedis.get.mockResolvedValue(null);\n      mockPrisma.configuration.findFirst.mockResolvedValue(testConfig);\n      mockRedis.setex.mockResolvedValue('OK');\n\n      const result = await configService.getConfiguration(\n        'test-service',\n        'development'\n      );\n\n      expect(result).toBeDefined();\n      expect(mockPrisma.configuration.findFirst).toHaveBeenCalledWith({\n        where: {\n          serviceName: 'test-service',\n          environment: 'development',\n          isActive: true,\n        },\n        orderBy: { version: 'desc' },\n        include: { secrets: false },\n      });\n      expect(mockRedis.setex).toHaveBeenCalled();\n    });\n\n    it('should return null if configuration not found', async () => {\n      mockRedis.get.mockResolvedValue(null);\n      mockPrisma.configuration.findFirst.mockResolvedValue(null);\n\n      const result = await configService.getConfiguration(\n        'non-existent-service',\n        'development'\n      );\n\n      expect(result).toBeNull();\n    });\n\n    it('should fetch specific version when provided', async () => {\n      mockRedis.get.mockResolvedValue(null);\n      mockPrisma.configuration.findFirst.mockResolvedValue(\n        global.testUtils.generateTestConfiguration({ version: 2 })\n      );\n\n      await configService.getConfiguration('test-service', 'development', 2);\n\n      expect(mockPrisma.configuration.findFirst).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: expect.objectContaining({\n            version: 2,\n          }),\n        })\n      );\n    });\n  });\n\n  describe('updateConfiguration', () => {\n    it('should create new configuration version', async () => {\n      const existingConfig = global.testUtils.generateTestConfiguration({ version: 1 });\n      const newConfig = global.testUtils.generateTestConfiguration({ version: 2 });\n      \n      mockPrisma.configuration.findFirst.mockResolvedValue(existingConfig);\n      mockPrisma.configuration.update.mockResolvedValue(existingConfig);\n      mockPrisma.configuration.create.mockResolvedValue(newConfig);\n      mockPrisma.configurationAuditLog.create.mockResolvedValue({} as any);\n      mockRedis.keys.mockResolvedValue([]);\n      mockRedis.publish.mockResolvedValue(1);\n\n      const result = await configService.updateConfiguration(\n        'test-service',\n        'development',\n        { newKey: 'newValue' },\n        { updatedBy: 'test-user' }\n      );\n\n      expect(result).toBeDefined();\n      expect(mockPrisma.configuration.update).toHaveBeenCalledWith({\n        where: { id: existingConfig.id },\n        data: { isActive: false },\n      });\n      expect(mockPrisma.configuration.create).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: expect.objectContaining({\n            version: 2,\n            config: { newKey: 'newValue' },\n            isActive: true,\n          }),\n        })\n      );\n    });\n\n    it('should validate configuration when requested', async () => {\n      mockPrisma.configuration.findFirst.mockResolvedValue(null);\n      mockPrisma.serviceRegistry.findUnique.mockResolvedValue(null);\n      mockPrisma.configuration.create.mockResolvedValue(\n        global.testUtils.generateTestConfiguration()\n      );\n      mockPrisma.configurationAuditLog.create.mockResolvedValue({} as any);\n      mockRedis.keys.mockResolvedValue([]);\n      mockRedis.publish.mockResolvedValue(1);\n\n      const result = await configService.updateConfiguration(\n        'test-service',\n        'development',\n        { validKey: 'validValue' },\n        { validate: true }\n      );\n\n      expect(result.isValid).toBe(true);\n    });\n\n    it('should handle validation errors', async () => {\n      mockPrisma.configuration.findFirst.mockResolvedValue(null);\n      mockPrisma.serviceRegistry.findUnique.mockResolvedValue(null);\n      mockPrisma.configuration.create.mockResolvedValue(\n        global.testUtils.generateTestConfiguration({ isValid: false })\n      );\n      mockPrisma.configurationAuditLog.create.mockResolvedValue({} as any);\n      mockRedis.keys.mockResolvedValue([]);\n      mockRedis.publish.mockResolvedValue(1);\n\n      const result = await configService.updateConfiguration(\n        'test-service',\n        'development',\n        { invalidKey: 123 }, // This would fail validation in real scenario\n        { validate: true }\n      );\n\n      // In a real scenario, this would have validation errors\n      expect(result).toBeDefined();\n    });\n  });\n\n  describe('triggerConfigurationReload', () => {\n    it('should clear cache and publish reload event', async () => {\n      mockRedis.keys.mockResolvedValue(['config:test-service:development:1']);\n      mockRedis.del.mockResolvedValue(1);\n      mockRedis.publish.mockResolvedValue(1);\n\n      await configService.triggerConfigurationReload(\n        'test-service',\n        'development',\n        true\n      );\n\n      expect(mockRedis.keys).toHaveBeenCalledWith('config:test-service:development*');\n      expect(mockRedis.del).toHaveBeenCalledWith('config:test-service:development:1');\n      expect(mockRedis.publish).toHaveBeenCalledWith(\n        'config:reload:test-service:development',\n        expect.stringContaining('CONFIGURATION_RELOAD')\n      );\n    });\n  });\n\n  describe('getConfigurationHistory', () => {\n    it('should return paginated configuration history', async () => {\n      const testConfigs = [\n        global.testUtils.generateTestConfiguration({ version: 2 }),\n        global.testUtils.generateTestConfiguration({ version: 1 }),\n      ];\n      \n      mockPrisma.configuration.findMany.mockResolvedValue(\n        testConfigs.map(config => ({ ...config, auditLogs: [] }))\n      );\n\n      const result = await configService.getConfigurationHistory(\n        'test-service',\n        'development',\n        10,\n        0\n      );\n\n      expect(result).toHaveLength(2);\n      expect(result[0].version).toBe(2);\n      expect(result[1].version).toBe(1);\n      expect(mockPrisma.configuration.findMany).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: {\n            serviceName: 'test-service',\n            environment: 'development',\n          },\n          orderBy: { version: 'desc' },\n          take: 10,\n          skip: 0,\n        })\n      );\n    });\n  });\n\n  describe('registerService', () => {\n    it('should create new service registration', async () => {\n      const serviceData = {\n        serviceName: 'new-service',\n        displayName: 'New Service',\n        version: '1.0.0',\n        endpoints: ['http://localhost:3000'],\n        requiredConfigs: ['DATABASE_URL'],\n        optionalConfigs: ['CACHE_URL'],\n        environment: 'development' as const,\n        tags: ['api'],\n      };\n      \n      mockPrisma.serviceRegistry.findUnique.mockResolvedValue(null);\n      mockPrisma.serviceRegistry.create.mockResolvedValue({\n        id: 'service-id',\n        ...serviceData,\n        description: null,\n        healthCheck: null,\n        configSchema: null,\n        isActive: true,\n        lastSeen: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        registeredBy: 'test-user',\n      });\n\n      const result = await configService.registerService(serviceData, 'test-user');\n\n      expect(result).toBeDefined();\n      expect(mockPrisma.serviceRegistry.create).toHaveBeenCalledWith(\n        expect.objectContaining({\n          data: expect.objectContaining({\n            serviceName: 'new-service',\n            registeredBy: 'test-user',\n          }),\n        })\n      );\n    });\n\n    it('should update existing service registration', async () => {\n      const existingService = {\n        id: 'existing-service-id',\n        serviceName: 'existing-service',\n        displayName: 'Existing Service',\n        version: '1.0.0',\n        endpoints: ['http://localhost:3000'],\n        requiredConfigs: ['DATABASE_URL'],\n        optionalConfigs: [],\n        environment: 'development',\n        tags: ['api'],\n        description: null,\n        healthCheck: null,\n        configSchema: null,\n        isActive: true,\n        lastSeen: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        registeredBy: 'test-user',\n      };\n      \n      const updateData = {\n        serviceName: 'existing-service',\n        displayName: 'Updated Service',\n        version: '2.0.0',\n        endpoints: ['http://localhost:4000'],\n        requiredConfigs: ['DATABASE_URL', 'REDIS_URL'],\n        optionalConfigs: ['CACHE_URL'],\n        environment: 'development' as const,\n        tags: ['api', 'updated'],\n      };\n      \n      mockPrisma.serviceRegistry.findUnique.mockResolvedValue(existingService);\n      mockPrisma.serviceRegistry.update.mockResolvedValue({\n        ...existingService,\n        ...updateData,\n      });\n\n      const result = await configService.registerService(updateData);\n\n      expect(result).toBeDefined();\n      expect(mockPrisma.serviceRegistry.update).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: { serviceName: 'existing-service' },\n          data: expect.objectContaining({\n            displayName: 'Updated Service',\n            version: '2.0.0',\n          }),\n        })\n      );\n    });\n  });\n\n  describe('healthCheck', () => {\n    it('should return healthy status when connections work', async () => {\n      mockPrisma.$queryRaw.mockResolvedValue([]);\n      mockRedis.ping.mockResolvedValue('PONG');\n\n      const result = await configService.healthCheck();\n\n      expect(result.healthy).toBe(true);\n      expect(mockPrisma.$queryRaw).toHaveBeenCalledWith(\n        expect.anything() // SELECT 1 query\n      );\n      expect(mockRedis.ping).toHaveBeenCalled();\n    });\n\n    it('should return unhealthy status when database fails', async () => {\n      mockPrisma.$queryRaw.mockRejectedValue(new Error('Database connection failed'));\n      mockRedis.ping.mockResolvedValue('PONG');\n\n      const result = await configService.healthCheck();\n\n      expect(result.healthy).toBe(false);\n      expect(result.details).toBeDefined();\n      expect(result.details.error).toContain('Database connection failed');\n    });\n\n    it('should return unhealthy status when Redis fails', async () => {\n      mockPrisma.$queryRaw.mockResolvedValue([]);\n      mockRedis.ping.mockRejectedValue(new Error('Redis connection failed'));\n\n      const result = await configService.healthCheck();\n\n      expect(result.healthy).toBe(false);\n      expect(result.details).toBeDefined();\n      expect(result.details.error).toContain('Redis connection failed');\n    });\n  });\n\n  describe('subscribeToConfigurationChanges', () => {\n    it('should add subscription and store in database', async () => {\n      mockPrisma.configurationSubscription.upsert.mockResolvedValue({} as any);\n\n      await configService.subscribeToConfigurationChanges(\n        'test-service',\n        'connection-123'\n      );\n\n      expect(mockPrisma.configurationSubscription.upsert).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: { connectionId: 'connection-123' },\n          create: expect.objectContaining({\n            serviceName: 'test-service',\n            connectionId: 'connection-123',\n          }),\n        })\n      );\n    });\n  });\n\n  describe('unsubscribeFromConfigurationChanges', () => {\n    it('should remove subscription and mark as inactive', async () => {\n      mockPrisma.configurationSubscription.updateMany.mockResolvedValue({ count: 1 });\n\n      await configService.unsubscribeFromConfigurationChanges(\n        'test-service',\n        'connection-123'\n      );\n\n      expect(mockPrisma.configurationSubscription.updateMany).toHaveBeenCalledWith(\n        expect.objectContaining({\n          where: { connectionId: 'connection-123' },\n          data: { isActive: false },\n        })\n      );\n    });\n  });\n\n  describe('error handling', () => {\n    it('should handle database errors gracefully', async () => {\n      mockRedis.get.mockResolvedValue(null);\n      mockPrisma.configuration.findFirst.mockRejectedValue(\n        new Error('Database error')\n      );\n\n      await expect(\n        configService.getConfiguration('test-service', 'development')\n      ).rejects.toThrow('Database error');\n    });\n\n    it('should handle Redis errors gracefully', async () => {\n      mockRedis.get.mockRejectedValue(new Error('Redis error'));\n      mockPrisma.configuration.findFirst.mockResolvedValue(\n        global.testUtils.generateTestConfiguration()\n      );\n\n      // Should fall back to database when Redis fails\n      const result = await configService.getConfiguration(\n        'test-service',\n        'development'\n      );\n\n      expect(result).toBeDefined();\n      expect(mockPrisma.configuration.findFirst).toHaveBeenCalled();\n    });\n  });\n\n  describe('events', () => {\n    it('should emit configurationUpdated event', async () => {\n      const eventSpy = jest.fn();\n      configService.on('configurationUpdated', eventSpy);\n      \n      mockPrisma.configuration.findFirst.mockResolvedValue(null);\n      mockPrisma.configuration.create.mockResolvedValue(\n        global.testUtils.generateTestConfiguration()\n      );\n      mockPrisma.configurationAuditLog.create.mockResolvedValue({} as any);\n      mockRedis.keys.mockResolvedValue([]);\n      mockRedis.publish.mockResolvedValue(1);\n\n      await configService.updateConfiguration(\n        'test-service',\n        'development',\n        { key: 'value' }\n      );\n\n      expect(eventSpy).toHaveBeenCalledWith(\n        expect.objectContaining({\n          serviceName: 'test-service',\n          environment: 'development',\n        })\n      );\n    });\n\n    it('should emit serviceRegistered event', async () => {\n      const eventSpy = jest.fn();\n      configService.on('serviceRegistered', eventSpy);\n      \n      const serviceData = {\n        serviceName: 'test-service',\n        displayName: 'Test Service',\n        version: '1.0.0',\n        endpoints: [],\n        requiredConfigs: [],\n        optionalConfigs: [],\n        environment: 'development' as const,\n        tags: [],\n      };\n      \n      mockPrisma.serviceRegistry.findUnique.mockResolvedValue(null);\n      mockPrisma.serviceRegistry.create.mockResolvedValue({\n        id: 'service-id',\n        ...serviceData,\n        description: null,\n        healthCheck: null,\n        configSchema: null,\n        isActive: true,\n        lastSeen: new Date(),\n        createdAt: new Date(),\n        updatedAt: new Date(),\n        registeredBy: null,\n      });\n\n      await configService.registerService(serviceData);\n\n      expect(eventSpy).toHaveBeenCalled();\n    });\n  });\n});"