// Monitoring and Metrics Collection for Configuration Management System\n// Provides performance monitoring, health checks, and operational metrics\n\nimport { EventEmitter } from 'events';\nimport { NodeEnvironment, MetricPoint, SystemMetrics } from '../types';\nimport { Logger } from './logger';\n\nexport interface MetricOptions {\n  labels?: Record<string, string>;\n  timestamp?: Date;\n}\n\nexport interface AlertRule {\n  id: string;\n  name: string;\n  condition: (metrics: SystemMetrics) => boolean;\n  severity: 'low' | 'medium' | 'high' | 'critical';\n  cooldownMs: number;\n  lastTriggered?: Date;\n}\n\nexport interface HealthCheck {\n  name: string;\n  check: () => Promise<{ healthy: boolean; details?: any }>;\n  timeout: number;\n  critical: boolean;\n}\n\nexport class MonitoringService extends EventEmitter {\n  private logger: Logger;\n  private metrics: Map<string, MetricPoint[]> = new Map();\n  private counters: Map<string, number> = new Map();\n  private gauges: Map<string, number> = new Map();\n  private histograms: Map<string, number[]> = new Map();\n  private healthChecks: Map<string, HealthCheck> = new Map();\n  private alertRules: Map<string, AlertRule> = new Map();\n  private metricsRetentionMs: number;\n  private metricsCleanupInterval: NodeJS.Timeout;\n\n  constructor(\n    logger: Logger,\n    options: {\n      metricsRetentionMs?: number;\n      cleanupIntervalMs?: number;\n    } = {}\n  ) {\n    super();\n    this.logger = logger;\n    this.metricsRetentionMs = options.metricsRetentionMs || 3600000; // 1 hour\n    \n    // Start periodic cleanup\n    this.metricsCleanupInterval = setInterval(\n      () => this.cleanupOldMetrics(),\n      options.cleanupIntervalMs || 300000 // 5 minutes\n    );\n  }\n\n  // Counter metrics (monotonically increasing)\n  incrementCounter(name: string, value: number = 1, options?: MetricOptions): void {\n    const key = this.buildMetricKey(name, options?.labels);\n    const currentValue = this.counters.get(key) || 0;\n    this.counters.set(key, currentValue + value);\n    \n    this.recordMetricPoint(name, currentValue + value, options);\n    this.emit('counterIncrement', { name, value, labels: options?.labels });\n  }\n\n  // Gauge metrics (can go up or down)\n  setGauge(name: string, value: number, options?: MetricOptions): void {\n    const key = this.buildMetricKey(name, options?.labels);\n    this.gauges.set(key, value);\n    \n    this.recordMetricPoint(name, value, options);\n    this.emit('gaugeSet', { name, value, labels: options?.labels });\n  }\n\n  // Histogram metrics (for timing and distribution)\n  recordHistogram(name: string, value: number, options?: MetricOptions): void {\n    const key = this.buildMetricKey(name, options?.labels);\n    const values = this.histograms.get(key) || [];\n    values.push(value);\n    \n    // Keep only recent values to prevent memory bloat\n    if (values.length > 1000) {\n      values.splice(0, values.length - 1000);\n    }\n    \n    this.histograms.set(key, values);\n    this.recordMetricPoint(name, value, options);\n    this.emit('histogramRecord', { name, value, labels: options?.labels });\n  }\n\n  // Timer utility for measuring duration\n  timer(name: string, options?: MetricOptions): () => void {\n    const startTime = Date.now();\n    \n    return () => {\n      const duration = Date.now() - startTime;\n      this.recordHistogram(name, duration, options);\n      \n      // Log slow operations\n      if (duration > 1000) {\n        this.logger.warn(`Slow operation detected: ${name} took ${duration}ms`, {\n          operation: name,\n          duration,\n          ...options?.labels,\n        });\n      }\n    };\n  }\n\n  // Get current metric values\n  getCounter(name: string, labels?: Record<string, string>): number {\n    const key = this.buildMetricKey(name, labels);\n    return this.counters.get(key) || 0;\n  }\n\n  getGauge(name: string, labels?: Record<string, string>): number | undefined {\n    const key = this.buildMetricKey(name, labels);\n    return this.gauges.get(key);\n  }\n\n  getHistogramStats(name: string, labels?: Record<string, string>): {\n    count: number;\n    sum: number;\n    avg: number;\n    min: number;\n    max: number;\n    p50: number;\n    p95: number;\n    p99: number;\n  } | null {\n    const key = this.buildMetricKey(name, labels);\n    const values = this.histograms.get(key);\n    \n    if (!values || values.length === 0) {\n      return null;\n    }\n    \n    const sorted = [...values].sort((a, b) => a - b);\n    const sum = values.reduce((acc, val) => acc + val, 0);\n    \n    return {\n      count: values.length,\n      sum,\n      avg: sum / values.length,\n      min: sorted[0],\n      max: sorted[sorted.length - 1],\n      p50: this.percentile(sorted, 0.5),\n      p95: this.percentile(sorted, 0.95),\n      p99: this.percentile(sorted, 0.99),\n    };\n  }\n\n  // Get time series data for a metric\n  getMetricTimeSeries(\n    name: string,\n    startTime?: Date,\n    endTime?: Date,\n    labels?: Record<string, string>\n  ): MetricPoint[] {\n    const key = this.buildMetricKey(name, labels);\n    const points = this.metrics.get(key) || [];\n    \n    return points.filter(point => {\n      if (startTime && point.timestamp < startTime) return false;\n      if (endTime && point.timestamp > endTime) return false;\n      return true;\n    });\n  }\n\n  // Health check management\n  registerHealthCheck(healthCheck: HealthCheck): void {\n    this.healthChecks.set(healthCheck.name, healthCheck);\n    this.logger.info(`Health check registered: ${healthCheck.name}`);\n  }\n\n  unregisterHealthCheck(name: string): void {\n    this.healthChecks.delete(name);\n    this.logger.info(`Health check unregistered: ${name}`);\n  }\n\n  // Run all health checks\n  async runHealthChecks(): Promise<{\n    overall: 'healthy' | 'unhealthy' | 'degraded';\n    checks: Record<string, {\n      status: 'healthy' | 'unhealthy';\n      duration: number;\n      details?: any;\n      error?: string;\n    }>;\n  }> {\n    const results: Record<string, any> = {};\n    let criticalFailures = 0;\n    let totalFailures = 0;\n\n    const checkPromises = Array.from(this.healthChecks.entries()).map(async ([name, healthCheck]) => {\n      const startTime = Date.now();\n      \n      try {\n        const timeoutPromise = new Promise((_, reject) => {\n          setTimeout(() => reject(new Error('Health check timeout')), healthCheck.timeout);\n        });\n        \n        const checkResult = await Promise.race([\n          healthCheck.check(),\n          timeoutPromise,\n        ]) as { healthy: boolean; details?: any };\n        \n        const duration = Date.now() - startTime;\n        \n        results[name] = {\n          status: checkResult.healthy ? 'healthy' : 'unhealthy',\n          duration,\n          details: checkResult.details,\n        };\n        \n        if (!checkResult.healthy) {\n          totalFailures++;\n          if (healthCheck.critical) {\n            criticalFailures++;\n          }\n        }\n        \n        // Record metrics\n        this.setGauge(`health_check_duration_ms`, duration, { check: name });\n        this.setGauge(`health_check_status`, checkResult.healthy ? 1 : 0, { check: name });\n        \n      } catch (error) {\n        const duration = Date.now() - startTime;\n        \n        results[name] = {\n          status: 'unhealthy',\n          duration,\n          error: error instanceof Error ? error.message : String(error),\n        };\n        \n        totalFailures++;\n        if (healthCheck.critical) {\n          criticalFailures++;\n        }\n        \n        this.logger.error(`Health check failed: ${name}`, { check: name }, error as Error);\n      }\n    });\n\n    await Promise.all(checkPromises);\n\n    // Determine overall status\n    let overall: 'healthy' | 'unhealthy' | 'degraded';\n    if (criticalFailures > 0) {\n      overall = 'unhealthy';\n    } else if (totalFailures > 0) {\n      overall = 'degraded';\n    } else {\n      overall = 'healthy';\n    }\n\n    this.setGauge('system_health_status', overall === 'healthy' ? 1 : overall === 'degraded' ? 0.5 : 0);\n    \n    return { overall, checks: results };\n  }\n\n  // Alert rule management\n  registerAlertRule(rule: AlertRule): void {\n    this.alertRules.set(rule.id, rule);\n    this.logger.info(`Alert rule registered: ${rule.name}`);\n  }\n\n  unregisterAlertRule(id: string): void {\n    this.alertRules.delete(id);\n    this.logger.info(`Alert rule unregistered: ${id}`);\n  }\n\n  // Check alert rules against current metrics\n  checkAlertRules(metrics: SystemMetrics): void {\n    const now = new Date();\n    \n    for (const [id, rule] of this.alertRules.entries()) {\n      // Check cooldown\n      if (rule.lastTriggered && \n          (now.getTime() - rule.lastTriggered.getTime()) < rule.cooldownMs) {\n        continue;\n      }\n      \n      try {\n        const shouldAlert = rule.condition(metrics);\n        \n        if (shouldAlert) {\n          rule.lastTriggered = now;\n          \n          this.logger.warn(`Alert triggered: ${rule.name}`, {\n            alertId: rule.id,\n            severity: rule.severity,\n            metrics: JSON.stringify(metrics),\n          });\n          \n          this.emit('alertTriggered', {\n            rule,\n            metrics,\n            timestamp: now,\n          });\n          \n          this.incrementCounter('alerts_triggered_total', 1, {\n            severity: rule.severity,\n            rule: rule.name,\n          });\n        }\n      } catch (error) {\n        this.logger.error(`Error evaluating alert rule: ${rule.name}`, { alertId: rule.id }, error as Error);\n      }\n    }\n  }\n\n  // Get comprehensive system metrics\n  getSystemMetrics(): SystemMetrics {\n    return {\n      configurations: {\n        totalConfigurations: this.getGauge('configurations_total') || 0,\n        activeConfigurations: this.getGauge('configurations_active') || 0,\n        configurationsByEnvironment: {\n          development: this.getGauge('configurations_by_env', { env: 'development' }) || 0,\n          staging: this.getGauge('configurations_by_env', { env: 'staging' }) || 0,\n          production: this.getGauge('configurations_by_env', { env: 'production' }) || 0,\n        },\n        configurationsByService: {},\n        recentUpdates: this.getMetricTimeSeries('configuration_updates', new Date(Date.now() - 3600000)),\n        validationErrors: this.getGauge('validation_errors_total') || 0,\n      },\n      featureFlags: {\n        totalFlags: this.getGauge('feature_flags_total') || 0,\n        enabledFlags: this.getGauge('feature_flags_enabled') || 0,\n        flagsWithRollout: this.getGauge('feature_flags_with_rollout') || 0,\n        flagsByEnvironment: {\n          development: this.getGauge('feature_flags_by_env', { env: 'development' }) || 0,\n          staging: this.getGauge('feature_flags_by_env', { env: 'staging' }) || 0,\n          production: this.getGauge('feature_flags_by_env', { env: 'production' }) || 0,\n        },\n        evaluationsPerMinute: this.getMetricTimeSeries('feature_flag_evaluations', new Date(Date.now() - 60000)),\n        rolloutProgress: {},\n      },\n      cache: {\n        hitRate: this.getGauge('cache_hit_rate') || 0,\n        missRate: this.getGauge('cache_miss_rate') || 0,\n        totalKeys: this.getGauge('cache_keys_total') || 0,\n        memoryUsage: this.getGauge('cache_memory_usage_bytes') || 0,\n        operationsPerSecond: this.getMetricTimeSeries('cache_operations', new Date(Date.now() - 1000)),\n        averageResponseTime: this.getHistogramStats('cache_operation_duration_ms')?.avg || 0,\n      },\n      webSocket: {\n        activeConnections: this.getGauge('websocket_connections_active') || 0,\n        connectionsByService: {},\n        messagesPerMinute: this.getMetricTimeSeries('websocket_messages', new Date(Date.now() - 60000)),\n      },\n      database: {\n        connectionPoolSize: this.getGauge('db_connection_pool_size') || 0,\n        activeConnections: this.getGauge('db_connections_active') || 0,\n        averageQueryTime: this.getHistogramStats('db_query_duration_ms')?.avg || 0,\n        slowQueries: this.getCounter('db_slow_queries_total') || 0,\n      },\n    };\n  }\n\n  // Export metrics in Prometheus format\n  exportPrometheusMetrics(): string {\n    const lines: string[] = [];\n    \n    // Export counters\n    for (const [key, value] of this.counters.entries()) {\n      const { name, labels } = this.parseMetricKey(key);\n      const labelsStr = this.formatPrometheusLabels(labels);\n      lines.push(`# TYPE ${name}_total counter`);\n      lines.push(`${name}_total${labelsStr} ${value}`);\n    }\n    \n    // Export gauges\n    for (const [key, value] of this.gauges.entries()) {\n      const { name, labels } = this.parseMetricKey(key);\n      const labelsStr = this.formatPrometheusLabels(labels);\n      lines.push(`# TYPE ${name} gauge`);\n      lines.push(`${name}${labelsStr} ${value}`);\n    }\n    \n    // Export histograms\n    for (const [key, values] of this.histograms.entries()) {\n      const { name, labels } = this.parseMetricKey(key);\n      const labelsStr = this.formatPrometheusLabels(labels);\n      const stats = this.getHistogramStats(name, labels);\n      \n      if (stats) {\n        lines.push(`# TYPE ${name} histogram`);\n        lines.push(`${name}_count${labelsStr} ${stats.count}`);\n        lines.push(`${name}_sum${labelsStr} ${stats.sum}`);\n        lines.push(`${name}_bucket${this.formatPrometheusLabels({...labels, le: '0.5'})} ${this.countBelowThreshold(values, 0.5)}`);\n        lines.push(`${name}_bucket${this.formatPrometheusLabels({...labels, le: '0.95'})} ${this.countBelowThreshold(values, 0.95)}`);\n        lines.push(`${name}_bucket${this.formatPrometheusLabels({...labels, le: '0.99'})} ${this.countBelowThreshold(values, 0.99)}`);\n        lines.push(`${name}_bucket${this.formatPrometheusLabels({...labels, le: '+Inf'})} ${stats.count}`);\n      }\n    }\n    \n    return lines.join('\\n') + '\\n';\n  }\n\n  // Cleanup and shutdown\n  async shutdown(): Promise<void> {\n    if (this.metricsCleanupInterval) {\n      clearInterval(this.metricsCleanupInterval);\n    }\n    \n    this.metrics.clear();\n    this.counters.clear();\n    this.gauges.clear();\n    this.histograms.clear();\n    this.healthChecks.clear();\n    this.alertRules.clear();\n    \n    this.logger.info('Monitoring service shut down');\n  }\n\n  // Private helper methods\n\n  private buildMetricKey(name: string, labels?: Record<string, string>): string {\n    if (!labels || Object.keys(labels).length === 0) {\n      return name;\n    }\n    \n    const labelPairs = Object.entries(labels)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([key, value]) => `${key}=\"${value}\"`)\n      .join(',');\n    \n    return `${name}{${labelPairs}}`;\n  }\n\n  private parseMetricKey(key: string): { name: string; labels: Record<string, string> } {\n    const match = key.match(/^([^{]+)(?:\\{(.+)\\})?$/);\n    if (!match) {\n      return { name: key, labels: {} };\n    }\n    \n    const name = match[1];\n    const labelsStr = match[2];\n    const labels: Record<string, string> = {};\n    \n    if (labelsStr) {\n      const labelPairs = labelsStr.split(',');\n      for (const pair of labelPairs) {\n        const [key, value] = pair.split('=');\n        labels[key] = value.replace(/^\"|\"$/g, '');\n      }\n    }\n    \n    return { name, labels };\n  }\n\n  private formatPrometheusLabels(labels: Record<string, string>): string {\n    if (!labels || Object.keys(labels).length === 0) {\n      return '';\n    }\n    \n    const labelPairs = Object.entries(labels)\n      .sort(([a], [b]) => a.localeCompare(b))\n      .map(([key, value]) => `${key}=\"${value}\"`)\n      .join(',');\n    \n    return `{${labelPairs}}`;\n  }\n\n  private recordMetricPoint(name: string, value: number, options?: MetricOptions): void {\n    const key = this.buildMetricKey(name, options?.labels);\n    const points = this.metrics.get(key) || [];\n    \n    points.push({\n      timestamp: options?.timestamp || new Date(),\n      value,\n      labels: options?.labels,\n    });\n    \n    this.metrics.set(key, points);\n  }\n\n  private cleanupOldMetrics(): void {\n    const cutoffTime = new Date(Date.now() - this.metricsRetentionMs);\n    \n    for (const [key, points] of this.metrics.entries()) {\n      const filteredPoints = points.filter(point => point.timestamp > cutoffTime);\n      if (filteredPoints.length === 0) {\n        this.metrics.delete(key);\n      } else {\n        this.metrics.set(key, filteredPoints);\n      }\n    }\n  }\n\n  private percentile(sortedValues: number[], p: number): number {\n    const index = p * (sortedValues.length - 1);\n    const lower = Math.floor(index);\n    const upper = Math.ceil(index);\n    \n    if (lower === upper) {\n      return sortedValues[lower];\n    }\n    \n    const weight = index - lower;\n    return sortedValues[lower] * (1 - weight) + sortedValues[upper] * weight;\n  }\n\n  private countBelowThreshold(values: number[], threshold: number): number {\n    return values.filter(value => value <= threshold).length;\n  }\n}"