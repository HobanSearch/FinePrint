// Custom Error Classes for Configuration Management System\n// Provides structured error handling with proper error codes and context\n\nimport { NodeEnvironment } from '../types';\n\n// Base error class for all configuration-related errors\nexport class ConfigurationError extends Error {\n  public readonly code: string;\n  public readonly service?: string;\n  public readonly environment?: NodeEnvironment;\n  public readonly configKey?: string;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      service?: string;\n      environment?: NodeEnvironment;\n      configKey?: string;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'ConfigurationError';\n    this.code = code;\n    this.service = options?.service;\n    this.environment = options?.environment;\n    this.configKey = options?.configKey;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    // Maintain proper stack trace for where our error was thrown (only V8)\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ConfigurationError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      service: this.service,\n      environment: this.environment,\n      configKey: this.configKey,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// Feature flag specific errors\nexport class FeatureFlagError extends Error {\n  public readonly code: string;\n  public readonly flagKey?: string;\n  public readonly context?: any;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      flagKey?: string;\n      context?: any;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'FeatureFlagError';\n    this.code = code;\n    this.flagKey = options?.flagKey;\n    this.context = options?.context;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, FeatureFlagError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      flagKey: this.flagKey,\n      context: this.context,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// Validation specific errors\nexport class ValidationError extends Error {\n  public readonly code: string;\n  public readonly path: string[];\n  public readonly rule?: string;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    path: string[],\n    options?: {\n      rule?: string;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'ValidationError';\n    this.code = code;\n    this.path = path;\n    this.rule = options?.rule;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, ValidationError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      path: this.path,\n      rule: this.rule,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// Secret management specific errors\nexport class SecretError extends Error {\n  public readonly code: string;\n  public readonly secretKey?: string;\n  public readonly configurationId?: string;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      secretKey?: string;\n      configurationId?: string;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'SecretError';\n    this.code = code;\n    this.secretKey = options?.secretKey;\n    this.configurationId = options?.configurationId;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, SecretError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      secretKey: this.secretKey,\n      configurationId: this.configurationId,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// Cache specific errors\nexport class CacheError extends Error {\n  public readonly code: string;\n  public readonly key?: string;\n  public readonly operation?: string;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      key?: string;\n      operation?: string;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'CacheError';\n    this.code = code;\n    this.key = options?.key;\n    this.operation = options?.operation;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, CacheError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      key: this.key,\n      operation: this.operation,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// WebSocket specific errors\nexport class WebSocketError extends Error {\n  public readonly code: string;\n  public readonly connectionId?: string;\n  public readonly messageType?: string;\n  public readonly details?: any;\n  public readonly timestamp: Date;\n\n  constructor(\n    message: string,\n    code: string,\n    options?: {\n      connectionId?: string;\n      messageType?: string;\n      details?: any;\n      cause?: Error;\n    }\n  ) {\n    super(message);\n    this.name = 'WebSocketError';\n    this.code = code;\n    this.connectionId = options?.connectionId;\n    this.messageType = options?.messageType;\n    this.details = options?.details;\n    this.timestamp = new Date();\n\n    if (options?.cause) {\n      this.stack = `${this.stack}\\nCaused by: ${options.cause.stack}`;\n    }\n\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(this, WebSocketError);\n    }\n  }\n\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      code: this.code,\n      connectionId: this.connectionId,\n      messageType: this.messageType,\n      details: this.details,\n      timestamp: this.timestamp.toISOString(),\n      stack: this.stack,\n    };\n  }\n}\n\n// Error code constants\nexport const ERROR_CODES = {\n  // Configuration errors\n  CONFIG_NOT_FOUND: 'CONFIG_NOT_FOUND',\n  CONFIG_INVALID: 'CONFIG_INVALID',\n  CONFIG_VERSION_CONFLICT: 'CONFIG_VERSION_CONFLICT',\n  CONFIG_VALIDATION_FAILED: 'CONFIG_VALIDATION_FAILED',\n  CONFIG_UNAUTHORIZED: 'CONFIG_UNAUTHORIZED',\n  CONFIG_SERVICE_UNAVAILABLE: 'CONFIG_SERVICE_UNAVAILABLE',\n\n  // Feature flag errors\n  FLAG_NOT_FOUND: 'FLAG_NOT_FOUND',\n  FLAG_INVALID_ROLLOUT: 'FLAG_INVALID_ROLLOUT',\n  FLAG_EVALUATION_FAILED: 'FLAG_EVALUATION_FAILED',\n  FLAG_DEPENDENCY_FAILED: 'FLAG_DEPENDENCY_FAILED',\n  FLAG_UNAUTHORIZED: 'FLAG_UNAUTHORIZED',\n\n  // Secret errors\n  SECRET_NOT_FOUND: 'SECRET_NOT_FOUND',\n  SECRET_EXPIRED: 'SECRET_EXPIRED',\n  SECRET_ENCRYPTION_FAILED: 'SECRET_ENCRYPTION_FAILED',\n  SECRET_DECRYPTION_FAILED: 'SECRET_DECRYPTION_FAILED',\n  SECRET_UNAUTHORIZED: 'SECRET_UNAUTHORIZED',\n\n  // Cache errors\n  CACHE_CONNECTION_FAILED: 'CACHE_CONNECTION_FAILED',\n  CACHE_OPERATION_FAILED: 'CACHE_OPERATION_FAILED',\n  CACHE_SERIALIZATION_FAILED: 'CACHE_SERIALIZATION_FAILED',\n\n  // WebSocket errors\n  WS_CONNECTION_FAILED: 'WS_CONNECTION_FAILED',\n  WS_MESSAGE_INVALID: 'WS_MESSAGE_INVALID',\n  WS_SUBSCRIPTION_FAILED: 'WS_SUBSCRIPTION_FAILED',\n\n  // Validation errors\n  VALIDATION_SCHEMA_INVALID: 'VALIDATION_SCHEMA_INVALID',\n  VALIDATION_REQUIRED_FIELD: 'VALIDATION_REQUIRED_FIELD',\n  VALIDATION_TYPE_MISMATCH: 'VALIDATION_TYPE_MISMATCH',\n  VALIDATION_CONSTRAINT_VIOLATION: 'VALIDATION_CONSTRAINT_VIOLATION',\n\n  // Database errors\n  DATABASE_CONNECTION_FAILED: 'DATABASE_CONNECTION_FAILED',\n  DATABASE_QUERY_FAILED: 'DATABASE_QUERY_FAILED',\n  DATABASE_CONSTRAINT_VIOLATION: 'DATABASE_CONSTRAINT_VIOLATION',\n\n  // Authorization errors\n  UNAUTHORIZED: 'UNAUTHORIZED',\n  FORBIDDEN: 'FORBIDDEN',\n  INSUFFICIENT_PERMISSIONS: 'INSUFFICIENT_PERMISSIONS',\n\n  // Rate limiting errors\n  RATE_LIMIT_EXCEEDED: 'RATE_LIMIT_EXCEEDED',\n\n  // System errors\n  INTERNAL_ERROR: 'INTERNAL_ERROR',\n  SERVICE_UNAVAILABLE: 'SERVICE_UNAVAILABLE',\n  TIMEOUT: 'TIMEOUT',\n} as const;\n\n// Error factory functions\nexport const createConfigurationError = (\n  message: string,\n  code: string,\n  options?: {\n    service?: string;\n    environment?: NodeEnvironment;\n    configKey?: string;\n    details?: any;\n    cause?: Error;\n  }\n): ConfigurationError => {\n  return new ConfigurationError(message, code, options);\n};\n\nexport const createFeatureFlagError = (\n  message: string,\n  code: string,\n  options?: {\n    flagKey?: string;\n    context?: any;\n    details?: any;\n    cause?: Error;\n  }\n): FeatureFlagError => {\n  return new FeatureFlagError(message, code, options);\n};\n\nexport const createValidationError = (\n  message: string,\n  code: string,\n  path: string[],\n  options?: {\n    rule?: string;\n    details?: any;\n    cause?: Error;\n  }\n): ValidationError => {\n  return new ValidationError(message, code, path, options);\n};\n\nexport const createSecretError = (\n  message: string,\n  code: string,\n  options?: {\n    secretKey?: string;\n    configurationId?: string;\n    details?: any;\n    cause?: Error;\n  }\n): SecretError => {\n  return new SecretError(message, code, options);\n};\n\nexport const createCacheError = (\n  message: string,\n  code: string,\n  options?: {\n    key?: string;\n    operation?: string;\n    details?: any;\n    cause?: Error;\n  }\n): CacheError => {\n  return new CacheError(message, code, options);\n};\n\nexport const createWebSocketError = (\n  message: string,\n  code: string,\n  options?: {\n    connectionId?: string;\n    messageType?: string;\n    details?: any;\n    cause?: Error;\n  }\n): WebSocketError => {\n  return new WebSocketError(message, code, options);\n};\n\n// Error handler utility\nexport const handleError = (error: any): {\n  statusCode: number;\n  errorCode: string;\n  message: string;\n  details?: any;\n} => {\n  // Handle known error types\n  if (error instanceof ConfigurationError) {\n    return {\n      statusCode: getStatusCodeForError(error.code),\n      errorCode: error.code,\n      message: error.message,\n      details: error.details,\n    };\n  }\n\n  if (error instanceof FeatureFlagError) {\n    return {\n      statusCode: getStatusCodeForError(error.code),\n      errorCode: error.code,\n      message: error.message,\n      details: error.details,\n    };\n  }\n\n  if (error instanceof ValidationError) {\n    return {\n      statusCode: 400,\n      errorCode: error.code,\n      message: error.message,\n      details: {\n        path: error.path,\n        rule: error.rule,\n        ...error.details,\n      },\n    };\n  }\n\n  if (error instanceof SecretError) {\n    return {\n      statusCode: getStatusCodeForError(error.code),\n      errorCode: error.code,\n      message: error.message,\n      details: error.details,\n    };\n  }\n\n  if (error instanceof CacheError) {\n    return {\n      statusCode: 503,\n      errorCode: error.code,\n      message: error.message,\n      details: error.details,\n    };\n  }\n\n  if (error instanceof WebSocketError) {\n    return {\n      statusCode: 400,\n      errorCode: error.code,\n      message: error.message,\n      details: error.details,\n    };\n  }\n\n  // Handle unknown errors\n  return {\n    statusCode: 500,\n    errorCode: ERROR_CODES.INTERNAL_ERROR,\n    message: 'An internal error occurred',\n    details: {\n      originalError: error.message,\n      stack: error.stack,\n    },\n  };\n};\n\n// Get appropriate HTTP status code for error code\nconst getStatusCodeForError = (errorCode: string): number => {\n  const statusCodes: Record<string, number> = {\n    [ERROR_CODES.CONFIG_NOT_FOUND]: 404,\n    [ERROR_CODES.CONFIG_INVALID]: 400,\n    [ERROR_CODES.CONFIG_VERSION_CONFLICT]: 409,\n    [ERROR_CODES.CONFIG_VALIDATION_FAILED]: 400,\n    [ERROR_CODES.CONFIG_UNAUTHORIZED]: 401,\n    [ERROR_CODES.CONFIG_SERVICE_UNAVAILABLE]: 503,\n\n    [ERROR_CODES.FLAG_NOT_FOUND]: 404,\n    [ERROR_CODES.FLAG_INVALID_ROLLOUT]: 400,\n    [ERROR_CODES.FLAG_EVALUATION_FAILED]: 500,\n    [ERROR_CODES.FLAG_DEPENDENCY_FAILED]: 400,\n    [ERROR_CODES.FLAG_UNAUTHORIZED]: 401,\n\n    [ERROR_CODES.SECRET_NOT_FOUND]: 404,\n    [ERROR_CODES.SECRET_EXPIRED]: 410,\n    [ERROR_CODES.SECRET_ENCRYPTION_FAILED]: 500,\n    [ERROR_CODES.SECRET_DECRYPTION_FAILED]: 500,\n    [ERROR_CODES.SECRET_UNAUTHORIZED]: 401,\n\n    [ERROR_CODES.UNAUTHORIZED]: 401,\n    [ERROR_CODES.FORBIDDEN]: 403,\n    [ERROR_CODES.INSUFFICIENT_PERMISSIONS]: 403,\n    [ERROR_CODES.RATE_LIMIT_EXCEEDED]: 429,\n    [ERROR_CODES.TIMEOUT]: 408,\n    [ERROR_CODES.SERVICE_UNAVAILABLE]: 503,\n  };\n\n  return statusCodes[errorCode] || 500;\n};\n\n// Utility to check if an error is retryable\nexport const isRetryableError = (error: any): boolean => {\n  const retryableCodes = [\n    ERROR_CODES.CONFIG_SERVICE_UNAVAILABLE,\n    ERROR_CODES.CACHE_CONNECTION_FAILED,\n    ERROR_CODES.DATABASE_CONNECTION_FAILED,\n    ERROR_CODES.TIMEOUT,\n    ERROR_CODES.SERVICE_UNAVAILABLE,\n  ];\n\n  if (error instanceof ConfigurationError || \n      error instanceof FeatureFlagError || \n      error instanceof SecretError || \n      error instanceof CacheError) {\n    return retryableCodes.includes(error.code);\n  }\n\n  // Network errors are typically retryable\n  if (error.code === 'ECONNRESET' || \n      error.code === 'ECONNREFUSED' || \n      error.code === 'ETIMEDOUT') {\n    return true;\n  }\n\n  return false;\n};