import axios, { 
  AxiosResponse, 
  AxiosError, 
  InternalAxiosRequestConfig,
  AxiosRequestConfig 
} from 'axios'
import NetInfo from '@react-native-community/netinfo'\nimport * as SecureStore from 'expo-secure-store'\nimport { MMKV } from 'react-native-mmkv'\n\n// Environment configuration\nconst API_BASE_URL = process.env.API_URL || 'http://localhost:8080/api'\nconst WS_BASE_URL = process.env.WS_URL || 'ws://localhost:8080'\n\n// Storage instances\nconst secureStorage = new MMKV({ id: 'secure-api-storage', encryptionKey: 'api-encryption-key' })\nconst AUTH_STORAGE_KEY = 'fineprint_auth'\n\n// Create axios instance\nexport const apiClient = axios.create({\n  baseURL: API_BASE_URL,\n  timeout: 30000,\n  headers: {\n    'Content-Type': 'application/json',\n    'X-Client-Version': '1.0.0',\n    'X-Platform': 'mobile'\n  }\n})\n\n// Network status tracking\nlet isOnline = true\nlet networkUnsubscribe: (() => void) | null = null\n\n// Initialize network monitoring\nexport function initializeNetworkMonitoring() {\n  networkUnsubscribe = NetInfo.addEventListener(state => {\n    isOnline = Boolean(state.isConnected && state.isInternetReachable)\n  })\n  \n  return () => {\n    if (networkUnsubscribe) {\n      networkUnsubscribe()\n      networkUnsubscribe = null\n    }\n  }\n}\n\n// Request interceptor to add auth token and handle offline\napiClient.interceptors.request.use(\n  async (config: InternalAxiosRequestConfig) => {\n    try {\n      // Check network status\n      if (!isOnline) {\n        throw new Error('No internet connection')\n      }\n\n      // Get stored auth data\n      const authData = secureStorage.getString(AUTH_STORAGE_KEY)\n      \n      if (authData) {\n        const parsed = JSON.parse(authData)\n        if (parsed.tokens?.accessToken) {\n          config.headers.Authorization = `Bearer ${parsed.tokens.accessToken}`\n        }\n      }\n\n      // Add request ID for tracking\n      config.headers['X-Request-ID'] = generateRequestId()\n\n      // Add timestamp\n      config.headers['X-Request-Time'] = new Date().toISOString()\n\n      // Add device info\n      config.headers['X-Device-Info'] = JSON.stringify({\n        platform: 'mobile',\n        version: '1.0.0'\n      })\n\n      return config\n    } catch (error) {\n      console.error('Request interceptor error:', error)\n      return Promise.reject(error)\n    }\n  },\n  (error) => {\n    return Promise.reject(error)\n  }\n)\n\n// Response interceptor for error handling and token refresh\napiClient.interceptors.response.use(\n  (response: AxiosResponse) => {\n    return response\n  },\n  async (error: AxiosError) => {\n    const originalRequest = error.config as InternalAxiosRequestConfig & { _retry?: boolean }\n\n    // Handle network errors\n    if (!error.response && !isOnline) {\n      const networkError = new Error('Network unavailable. Request will be retried when connection is restored.')\n      networkError.name = 'NetworkError'\n      return Promise.reject(networkError)\n    }\n\n    // Handle 401 Unauthorized - Token expired\n    if (error.response?.status === 401 && !originalRequest._retry) {\n      originalRequest._retry = true\n\n      try {\n        // Get stored auth data\n        const authData = secureStorage.getString(AUTH_STORAGE_KEY)\n        \n        if (authData) {\n          const parsed = JSON.parse(authData)\n          \n          if (parsed.tokens?.refreshToken) {\n            // Attempt to refresh token\n            const refreshResponse = await axios.post(`${API_BASE_URL}/auth/refresh`, {\n              refreshToken: parsed.tokens.refreshToken\n            })\n\n            const newTokens = refreshResponse.data\n\n            // Update stored tokens\n            const updatedAuth = {\n              ...parsed,\n              tokens: newTokens\n            }\n            secureStorage.set(AUTH_STORAGE_KEY, JSON.stringify(updatedAuth))\n\n            // Update the original request with new token\n            originalRequest.headers.Authorization = `Bearer ${newTokens.accessToken}`\n\n            // Retry the original request\n            return apiClient(originalRequest)\n          }\n        }\n      } catch (refreshError) {\n        // Refresh failed - clear auth data and emit auth failure event\n        secureStorage.delete(AUTH_STORAGE_KEY)\n        \n        // Emit custom event for auth failure (to be handled by the store)\n        const authExpiredEvent = new CustomEvent('auth:expired', { detail: refreshError })\n        if (typeof window !== 'undefined') {\n          window.dispatchEvent(authExpiredEvent)\n        }\n        \n        return Promise.reject(refreshError)\n      }\n    }\n\n    // Handle other errors\n    const enhancedError = enhanceError(error)\n    return Promise.reject(enhancedError)\n  }\n)\n\n// Enhanced error handling\ninterface ApiError extends Error {\n  status?: number\n  code?: string\n  details?: any\n  requestId?: string\n  isNetworkError?: boolean\n}\n\nfunction enhanceError(error: AxiosError): ApiError {\n  const enhanced: ApiError = new Error(error.message)\n  \n  enhanced.name = 'ApiError'\n  enhanced.status = error.response?.status\n  enhanced.requestId = error.config?.headers?.['X-Request-ID'] as string\n  enhanced.isNetworkError = !error.response && !isOnline\n  \n  if (error.response?.data) {\n    const data = error.response.data as any\n    enhanced.message = data.message || data.error || error.message\n    enhanced.code = data.code\n    enhanced.details = data.details\n  }\n\n  // Add context based on status code\n  switch (error.response?.status) {\n    case 400:\n      enhanced.message = enhanced.message || 'Invalid request. Please check your input.'\n      break\n    case 401:\n      enhanced.message = enhanced.message || 'Authentication required. Please log in.'\n      break\n    case 403:\n      enhanced.message = enhanced.message || 'Access denied. You don\\'t have permission to perform this action.'\n      break\n    case 404:\n      enhanced.message = enhanced.message || 'The requested resource was not found.'\n      break\n    case 409:\n      enhanced.message = enhanced.message || 'Conflict. The resource already exists or is in use.'\n      break\n    case 413:\n      enhanced.message = enhanced.message || 'File too large. Please select a smaller file.'\n      break\n    case 429:\n      enhanced.message = enhanced.message || 'Too many requests. Please wait and try again.'\n      break\n    case 500:\n      enhanced.message = enhanced.message || 'Internal server error. Please try again later.'\n      break\n    case 502:\n    case 503:\n    case 504:\n      enhanced.message = enhanced.message || 'Service temporarily unavailable. Please try again later.'\n      break\n    default:\n      if (!error.response) {\n        enhanced.message = isOnline \n          ? 'Network error. Please check your connection.' \n          : 'No internet connection. Please check your network settings.'\n      }\n  }\n\n  return enhanced\n}\n\n// Retry helper for critical requests\nexport async function retryRequest<T>(\n  requestFn: () => Promise<T>,\n  maxRetries: number = 3,\n  baseDelay: number = 1000,\n  exponentialBackoff: boolean = true\n): Promise<T> {\n  let lastError: Error\n\n  for (let attempt = 1; attempt <= maxRetries; attempt++) {\n    try {\n      return await requestFn()\n    } catch (error) {\n      lastError = error as Error\n      \n      // Don't retry on client errors (4xx) except 408, 429\n      if (error instanceof Error && 'status' in error) {\n        const status = (error as any).status\n        if (status >= 400 && status < 500 && status !== 408 && status !== 429) {\n          throw error\n        }\n      }\n\n      // Don't retry on network errors if offline\n      if ((error as ApiError).isNetworkError && !isOnline) {\n        throw error\n      }\n\n      // Wait before retry\n      if (attempt < maxRetries) {\n        const delay = exponentialBackoff \n          ? baseDelay * Math.pow(2, attempt - 1)\n          : baseDelay\n        await new Promise(resolve => setTimeout(resolve, delay))\n      }\n    }\n  }\n\n  throw lastError!\n}\n\n// Specialized API methods with offline support\nexport const api = {\n  // Auth endpoints\n  auth: {\n    login: (email: string, password: string, rememberMe?: boolean) =>\n      apiClient.post('/auth/login', { \n        email, \n        password, \n        rememberMe,\n        deviceInfo: {\n          platform: 'mobile',\n          timestamp: new Date().toISOString()\n        }\n      }),\n    \n    logout: (refreshToken: string) =>\n      apiClient.post('/auth/logout', { refreshToken }),\n    \n    refresh: (refreshToken: string) =>\n      apiClient.post('/auth/refresh', { refreshToken }),\n    \n    signup: (email: string, password: string, displayName?: string) =>\n      apiClient.post('/auth/signup', { \n        email, \n        password, \n        displayName, \n        acceptTerms: true,\n        source: 'mobile'\n      }),\n    \n    forgotPassword: (email: string) =>\n      apiClient.post('/auth/forgot-password', { email }),\n    \n    resetPassword: (token: string, newPassword: string) =>\n      apiClient.post('/auth/reset-password', { token, newPassword }),\n    \n    changePassword: (currentPassword: string, newPassword: string) =>\n      apiClient.post('/auth/change-password', { currentPassword, newPassword })\n  },\n\n  // User endpoints\n  user: {\n    profile: () => apiClient.get('/user/profile'),\n    \n    updateProfile: (data: any) =>\n      apiClient.put('/user/profile', data),\n    \n    preferences: () => apiClient.get('/user/preferences'),\n    \n    updatePreferences: (preferences: any) =>\n      apiClient.put('/user/preferences', preferences),\n    \n    deleteAccount: () => apiClient.delete('/user/account')\n  },\n\n  // Document endpoints\n  documents: {\n    list: (params?: any) => apiClient.get('/documents', { params }),\n    \n    get: (id: string) => apiClient.get(`/documents/${id}`),\n    \n    upload: (formData: FormData, config?: AxiosRequestConfig) =>\n      apiClient.post('/documents/upload', formData, {\n        headers: { 'Content-Type': 'multipart/form-data' },\n        ...config\n      }),\n    \n    delete: (id: string) => apiClient.delete(`/documents/${id}`),\n    \n    update: (id: string, data: any) =>\n      apiClient.put(`/documents/${id}`, data)\n  },\n\n  // Analysis endpoints\n  analysis: {\n    list: (params?: any) => apiClient.get('/analysis', { params }),\n    \n    get: (id: string) => apiClient.get(`/analysis/${id}`),\n    \n    start: (data: any) => apiClient.post('/analysis/start', data),\n    \n    delete: (id: string) => apiClient.delete(`/analysis/${id}`),\n    \n    export: (id: string, format: 'pdf' | 'json' | 'csv') =>\n      apiClient.get(`/analysis/${id}/export`, {\n        params: { format },\n        responseType: 'blob'\n      }),\n      \n    share: (id: string) => apiClient.post(`/analysis/${id}/share`)\n  },\n\n  // System endpoints\n  system: {\n    status: () => apiClient.get('/system/status'),\n    \n    health: () => apiClient.get('/health'),\n    \n    version: () => apiClient.get('/system/version')\n  }\n}\n\n// Upload helper with progress tracking and offline support\nexport async function uploadWithProgress(\n  file: any,\n  onProgress?: (progress: number) => void,\n  allowOffline: boolean = true\n): Promise<AxiosResponse> {\n  // Check if online\n  if (!isOnline && !allowOffline) {\n    throw new Error('Upload requires internet connection')\n  }\n\n  const formData = new FormData()\n  formData.append('file', file)\n  formData.append('timestamp', new Date().toISOString())\n\n  return apiClient.post('/documents/upload', formData, {\n    headers: {\n      'Content-Type': 'multipart/form-data'\n    },\n    onUploadProgress: (progressEvent) => {\n      if (onProgress && progressEvent.total) {\n        const progress = Math.round(\n          (progressEvent.loaded * 100) / progressEvent.total\n        )\n        onProgress(progress)\n      }\n    }\n  })\n}\n\n// WebSocket URL helper\nexport function getWebSocketUrl(): string {\n  const wsProtocol = API_BASE_URL.startsWith('https') ? 'wss:' : 'ws:'\n  const wsHost = WS_BASE_URL.replace(/^https?:/, '').replace(/^ws:/, '')\n  return `${wsProtocol}${wsHost}/ws`\n}\n\n// Helper functions\nfunction generateRequestId(): string {\n  return `req_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`\n}\n\n// Export for store usage\nexport { isOnline }\nexport default apiClient"